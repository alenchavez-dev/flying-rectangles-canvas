<!DOCTYPE html>
<!--
  ============================================================
  Project: Flying Rectangles (HTML5 Canvas)
  Author:  Alen Chavez
  Purpose: Simple canvas animation that spawns colorful squares
           from the four corners and lets them bounce around.
  ============================================================
-->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flying Rectangles — Alen Chavez</title>
  <style>
    /* Make the canvas fill the page */
    html, body { height: 100%; margin: 0; background:#000; }
    canvas { display: block; }

    /* Simple overlay header for title/author */
    .banner{
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.55);
      color: #fff;
      padding: 8px 14px;
      border-radius: 8px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      z-index: 10;
      text-align: center;
      box-shadow: 0 4px 16px rgba(0,0,0,0.25);
      backdrop-filter: blur(2px);
    }
    .banner h1{ font-size: 16px; margin: 0; line-height: 1.25; letter-spacing: .2px; }
    .banner p{ font-size: 12px; margin: 2px 0 0; opacity: 0.9; }
  </style>
</head>
<body>
  <!-- Page heading (non-interactive) -->
  <header class="banner">
    <h1>Flying Rectangles — HTML5 Canvas</h1>
    <p>Author: Alen Chavez · Open the file and watch them bounce.</p>
  </header>

  <!-- The canvas we draw on -->
  <canvas id="stage"></canvas>

  <script>
    "use strict";
    /**
     * Flying Rectangles
     * ------------------
     * HTML5 Canvas demo that spawns colored squares at four
     * corners and lets them bounce around the screen.
     *
     * Key ideas:
     * - requestAnimationFrame for smooth updates
     * - Prototype-style particle object with position, size, velocity, color
     * - Simple edge-collision: reverse velocity on bounds
     */

    // Grab references and set up drawing context
    const canvas = document.getElementById("stage");
    const ctx = canvas.getContext("2d");

    // Keep canvas sized to the window
    let W = window.innerWidth;
    let H = window.innerHeight;

    // Handle HiDPI (Retina) displays for sharper rendering
    const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    function resizeCanvas() {
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width  = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width  = W + "px";
      canvas.style.height = H + "px";
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    // Four spawn points (the corners). New particles cycle through these.
    const SPAWN_POINTS = [
      { x: 12,     y: 12     },           // top-left
      { x: () => W - 24, y: 12     },     // top-right (x depends on width)
      { x: 12,     y: () => H - 24 },     // bottom-left (y depends on height)
      { x: () => W - 24, y: () => H - 24 } // bottom-right
    ];
    let spawnIndex = 0;

    // Prototype for a single moving square (particle).
    const particle = {
      x: 0, y: 0, r: 10, dx: 1, dy: 1, c: "#ffffff",

      // Factory method: create a new particle with initial state
      create: function (x, y, r, dx, dy) {
        const p = Object.create(this);
        p.x = x; p.y = y; p.r = r;
        p.dx = dx; p.dy = dy;
        p.c = getRandomColor();
        return p;
      },

      // Update position and bounce off edges (reverse velocity)
      move: function () {
        this.x += this.dx;
        this.y += this.dy;

        // Bounce horizontally
        if (this.x < 0) { this.x = 0; this.dx *= -1; }
        if (this.x + this.r > W) { this.x = W - this.r; this.dx *= -1; }

        // Bounce vertically
        if (this.y < 0) { this.y = 0; this.dy *= -1; }
        if (this.y + this.r > H) { this.y = H - this.r; this.dy *= -1; }
      },

      // Draw a filled square
      draw: function () {
        ctx.fillStyle = this.c;
        ctx.fillRect(this.x, this.y, this.r, this.r);
      }
    };

    // Returns either -1 or +1 with 50/50 chance.
    function randomSign() { return Math.random() < 0.5 ? -1 : 1; }

    // Generate a random hex color like #A1C3F2
    function getRandomColor() {
      const n = Math.floor(Math.random() * 0xFFFFFF);
      return "#" + n.toString(16).padStart(6, "0").toUpperCase();
    }

    // Create an initial set of particles (N determines density)
    const particles = [];
    const N = 120; // number of squares
    for (let i = 0; i < N; i++) {
      // Pick the current corner; support dynamic x/y when using functions
      const cornerRaw = SPAWN_POINTS[spawnIndex % SPAWN_POINTS.length];
      spawnIndex++;
      const corner = {
        x: typeof cornerRaw.x === "function" ? cornerRaw.x() : cornerRaw.x,
        y: typeof cornerRaw.y === "function" ? cornerRaw.y() : cornerRaw.y
      };

      const size = 6 + Math.floor(Math.random() * 16);        // 6..21 px
      const speed = 1 + Math.random() * 2.5;                  // 1..3.5
      const p = particle.create(corner.x, corner.y, size,
                                speed * randomSign(),
                                speed * randomSign());
      particles.push(p);
    }

    /**
     * Main animation loop:
     * - Clear the canvas
     * - Update + draw every particle
     * - Schedule the next frame
     */
    function update() {
      // Clear the entire canvas (black background already from <body>)
      ctx.clearRect(0, 0, W, H);

      // Update/draw all particles
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.move();
        p.draw();
      }

      // Ask the browser to call update() again before the next repaint
      requestAnimationFrame(update);
    }

    // Start the animation loop.
    update();
  </script>
</body>
</html>
